---
layout: post
title: DFS and practice questions
category: Data structure & Algorithms
tags:
  - Data structure & Algorithms
---
## basic DFS with backtracking
Let's say we are given list [1,2,3] and want to create permutation where
order matters so like [1,3,2], [2,1,3], [2,3,1] , etc.

I had 2 problems.

1) What do I iterate through in my DFS? The index of the list or the actual
number in the list?? The way to mark index or number as visited will differ
so I wasn't sure

2) I struggled with what parameters to pass in for my recursive dfs function. Should I pass
the next index (i+1) for DFS to go to the next index? But what about list
index out of range error? Certainly i+1 goes beyond my list and this error 
will occur!

### Doubts to clear
1) Actually either way is fine! But the way to mark index or number as visited
differs but that is the only difference

With index traversal:
```python
nums = [1,2,3]
visited = [False for _ in range(len(nums))]
ans = []
path =[]

def dfs(nums,path,visited):
    # index traversal
    for i in range(len(nums)):
        if len(path) == len(nums):
            ans.append(path.copy())
            return
        if not visited[i]:
            visited[i]=True
            path.append(nums[i])
            dfs(nums,path,visited)
            path.pop()
            visited[i]=False
            
dfs(nums,path,visited)
print(ans)
```

Here, I am accessing the index of nums list and marking the **index** of
visited list as true or false. Don't worry about backtracking yet we go in 
later.

With number traversal:
```python
nums = [1,2,3]
ans = []
path =[]

def dfs(nums,path):
    for num in nums:
        if len(path) == len(nums):
            ans.append(path.copy())
            return
        if num not in path:
            path.append(num)
            dfs(nums,path)
            path.pop()
         
dfs(nums,path)
print(ans)
```

As you can see, we cannot do something like
```python
visited = [False for _ in range(len(nums))]

def dfs(nums,path,visited):
    for i in nums:
        if len(path) == len(nums):
            ans.append(path)
            return
        if not visited[i]:
            visited[i]=True
            path.append(i)
            dfs(nums,path,visited)
            path.pop()
```

because I am accessing my boolean visited array with an actual number, not
the index. So in this case, we cannot use this way of marking number as visited.
Instead, there is a much simpler way - **if num not in list** ! This checks for
any incoming iterated number if it is already present (i.e. visited) in my
path list!

2) Actually, I was confused at the fundamental concept of not visited[index]
or **if num not in list**. We don't need to pass in the next index or value
and frankly we don't need to care because the boolean list or **if num not in list**
automatically checks this for us. 

Let's say we don't put index+1 as parameter for our recursive function. I 
am afraid it will recur back to index and go on infinite loop. Will it actually?

```python
def dfs(nums,path,visited):
    # index traversal
    for i in range(len(nums)):
        if len(path) == len(nums):
            ans.append(path.copy())
            return
        if not visited[i]:
            visited[i]=True
            path.append(nums[i])
            dfs(nums,path,visited)
            path.pop()
            visited[i]=False
```
Let's say i=1 and the corresponding number is 2 right. So we mark
visited[1] = True  and append 2 to our path. Then go to dfs(nums,path,visited).
i will go from 0 again. But it WILL NOT go on infinite loop check because 
of our boolean check or **if num not in list**. So i will go to 1 and since
it is already visited, it will go to 2. 

See? We don't need to pass index+1 as parameter.


## Example
Let's take this leetcode question as [example](https://leetcode.com/problems/battleships-in-a-board/description/)

If we encounter the X sign in 2x2 board, we do a DFS search
on that index.

BTW BFS is used to find SHORTEST distance.


## 2 conditions for DFS
1) Specify the end condition 

If DFS search goes beyond the boundary of the board +
**very important** if we meet an already visited node (for
example in this q, visited node is marked as dot while we
are looking for X)

2) Mark the current,visiting node as visited(true)

Or you will get StackOverflow error, which means recursion is never-
ending.

To make it as visited, we can create a 2x2 boolean array.
But try to mark on the given board itself to save space. For
example, here we can just mark visited node the same way as
the space not occupied by battleship, which is marked by dot.

## DFS template
```java
class Solution {
    public int countBattleships(char[][] board) {
        int count = 0;
        for(int i=0; i<board.length; i++){
            for(int j=0; j<board[0].length; j++){
                if(board[i][j]=='X'){
                    dfs(i, j, board);
                    count++;
                }
            }
        }
        return count;
    }
    private void dfs(int i, int j, char[][] board){
        if(i<0 || i>=board.length || j<0 || j>= board[0].length) return;
        if(board[i][j]=='.') return;
        board[i][j] = '.';
        dfs(i + 1, j, board);
        dfs(i - 1, j, board);
        dfs(i , j+1, board);
        dfs(i , j-1, board);
    }
}
```
