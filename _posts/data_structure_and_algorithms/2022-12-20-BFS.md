
---
layout: post
title: BFS template and practice questions
category: Data structure & Algorithms
tags:
  - Data structure & Algorithms
---
## Intro
Use queue for BFS to find **the shortest something**


## Practice questions
### 부대복귀
https://school.programmers.co.kr/learn/courses/30/lessons/132266

Let's start with a typical DFS question that picks a starting point and spreads
out in 4 directions grid to search for end point.

```python
from collections import deque
def solution(n, roads, sources, destination):
    # or just graph = defaultdict(list) 
    graph = [[] for _ in range(n+1)]
    for road in roads:
        start,end=road
        graph[start].append(end)
        graph[end].append(start)
    answer = []
    for source in sources:
        answer.append(bfs(graph,destination,n,source))
    return answer

def bfs(graph,destination,n,source):
    queue = deque()
    queue.append((source,0))
    visited = [False for _ in range(n+1)]
    visited[source]=True
    while queue:
        cur_node,cur_cost = queue.popleft()
        # you dont need this line here, do it when you are appending it to queue
        # visited[cur_node]=True
        if cur_node == destination:
            return cur_cost
        for next_node in graph[cur_node]:
            if not visited[next_node]:
                # do it here 
                visited[next_node]=True
                queue.append((next_node,cur_cost+1))
    return -1
```

My bfs is correct but it has runtime error for some large cases.

So how about instead of calculating distance from starting source to destination,
we do the other way around? My initial code will calculate distance
to destination multiple times if starting sources take the same shortest route
to destination. But if we do vice versa, we just calculate the distance from
destination to starting sources **once**.

Again my wrong code
```python
from collections import deque
def solution(n, roads, sources, destination):
    graph = [[] for _ in range(n+1)]
    for road in roads:
        start,end=road
        graph[start].append(end)
        graph[end].append(start)
    distance = [-1 for _ in range(n+1)]
    distance[destination]=0
    ans = bfs(graph,destination,n,distance)
    return [ans[i] for i in sources]
        

def bfs(graph,destination,n,distance):
    queue = deque()
    queue.append((destination,0))
    
    while queue:
        cur_node,cur_cost = queue.popleft()
        # u dont need this line, mark it when you are appending it to queue
        # distance[cur_node]=cur_cost
        for next_node in graph[cur_node]:
            if distance[next_node]== -1:
                queue.append((next_node,cur_cost+1))
    #             need this line
                distance[next_node] = cur_cost + 1
    return distance

```

This 1 line makes the difference. I thought you don't have to update distance
of next_node's cost because we do that in the queue via distance[cur_node]=cur_cost.

### 거리두기 확인하기
https://school.programmers.co.kr/learn/courses/30/lessons/81302

This question needs BFS search multiple times on the same board itself.
I didn't know how to get the value of BFS search result and if abnormal, append
to answer list. To do this, we can use **flag**. We first set flag as True
or value 1 and when BFS search comes out abnormal, we can set flag as False
based on that BFS search result condition.

Also, it is smart to optimise the movement loop like instead of 
```python
movements = [[1,0],[-1,0],[0,-1],[0,1]]
```

We can use a dictionary like 
```python
dic = {0: [0, -1], 1:[-1, 0], 2:[0, 1], 3:[1, 0]}
```

Also be very careful with difference on number 0 and alphabet O. I put it like
if place at dx,dy ='0' but it should have been alphabet O.

My attempt, which is wrong
```python
for i in range(4):
    nx = x + dic[i][0]
    ny = y + dic[i][1]
    nd = d + 1
    # if dx<0 or dy <0 or dx>=5 or dy >=5:
    #     continue
    if 0 <= dx < 5 and 0 <= dy < 5 and not visited[dx][dy]:
        visited[dx][dy]= True
        if place[dx][dy]=='P':
            if dist<=2:
                return 0
        elif place[dx][dy] =='0':
            if dist==1:
                queue.append([dx,dy,dist])
```

Correct
```python
from collections import deque
ans=[]

def bfs(place,pos):
  queue = deque([pos])
  visited = [[False for _ in range(5)] for _ in range(5)]
  dic = {0: [0, -1], 1:[-1, 0], 2:[0, 1], 3:[1, 0]}

  while queue:
    x,y,d = queue.popleft()
    visited[x][y] = True
    for i in range(4):
      dx = x + dic[i][0]
      dy = y + dic[i][1]
      dist = d+1
      if dx<0 or dy <0 or dx>=5 or dy >=5:
        continue
      if not visited[dx][dy]:
        visited[dx][dy]= True
        if place[dx][dy]=='P' and dist<=2:
          return 0
        elif place[dx][dy] =='O' and dist<=1:
          queue.append([dx,dy,dist])
  return 1


def solution(places):
  # global ans
  for place in places:
    flag =1
    for row in range(len(places[0])):
      for col in range(len(places)):
        if place[row][col]=='P':
          val = bfs(place,[row,col,0])
          if val == False:
            flag =0
    ans.append(1 if flag==1 else 0)
  return ans
```

### 
In my queue, the parameters that I store will lead to wrong answer. I store
the previous direction as well

My solution
```python
from collections import deque
def solution(board):
    visited= [[False for _ in range(len(board[0]))] for _ in range(len(board))]
    length = len(board)
    queue = deque()
    # queue.append((0, 0, 0, dir))
    answer=[]

    queue.append((0, 0, 1, 0, 0))
    queue.append((0,0,0,1,0))
    visited[0][0] = True

    while queue:
        moves = [[1,0],[-1,0],[0,-1],[0,1]]
        x,y,prevX,prevY, cost = queue.popleft()
        for move in moves:
            dx,dy= x+move[0],y+move[1]
            if dx<0 or dx>=len(board[0]) or dy<0 or dy>=length or board[dx][dy]==1:
                continue
            if dx == len(board[0]) - 1 and dy == length - 1:
                answer.append(cost)

            cost += check_direction(move[0],move[1],prevX,prevY,cost)
            print(cost)

            if not visited[dx][dy]:
                visited[dx][dy]= True
                queue.append((dx,dy,move[0],move[1],cost))
                print((dx,dy,move[0],move[1],cost))

    return min(answer)

def check_direction(nextX,nextY,prevX,prevY,cost):
    if prevX == nextX and prevY==nextY:
        cost+=100
    else:
        cost+=500
    return cost

solution([[0,0,0],[0,0,0],[0,0,0]])
```

But this will that when bfs starts on starting point 0,0, we can move both
directions - right and down. So in this case, we use a little trick that marks
a custom direction just for this edge case. We mark the direction as integer 5.

I tried fixing code like this but still didnt work. I think its cuz this
visited is not allowing other paths stored in my queue to explore properly.
Also my cost is mega huge idk why

```python
from collections import deque
def solution(board):
    visited= [[False for _ in range(len(board[0]))] for _ in range(len(board))]
    length = len(board)
    queue = deque()
    answer=[]

    # current x, current y, direction, cost
    queue.append((0, 0, 5, 0))
    visited[0][0] = True

    while queue:
        moves = [[1,0],[-1,0],[0,-1],[0,1]]
        x,y,prevDirection, cost = queue.popleft()
        for i in range(len(moves)):
            dx,dy= x+moves[i][0],y+moves[i][1]
            if dx<0 or dx>=len(board[0]) or dy<0 or dy>=length or board[dx][dy]==1:
                continue
            if dx == len(board[0]) - 1 and dy == length - 1:
                answer.append(cost)

            cost += check_direction(i,prevDirection,cost)
            print(cost)

            if not visited[dx][dy]:
                visited[dx][dy]= True
                queue.append((dx,dy,i,cost))
                print((dx,dy,i,cost))

    return min(answer)

def check_direction(currentDirection, prevDirection,cost):
    if prevDirection ==5:
        cost+=100
    elif currentDirection==prevDirection:
        cost+=100
    else:
        cost+=500
    return cost

solution([[0,0,0],[0,0,0],[0,0,0]])
```

But official solution is here. We actually dont create a visited list because
other paths stored in queue will not be able to visit the already-visited points
by another path that has been processed earlier. So instead, we allow possibility
that other paths will go back and forth and back and forth because there
is no mark of visited points. But we create a price 2d list that record
the smallest price of any path that visits that point.

Ok my explanation above is wrong (June 11th fix) So even though there is no
visited list, we have this condition that stop unnecessary paths from being
added to our queue. The condition is if the point that we are visiting has
a cost that is recorded and is higher than our current cost to visit it,
we override that value. So if our current cost is higher, that means there
is a path that has lower cost that has been already added to our queue. So,
we don't visit that point and try other path.

Like this:
```python
if nc <= price[nx][ny]:
    price[nx][ny] = nc
    queue.append((nx, ny, nc, i))
```

```python
from collections import deque

dx = [0, 0, 1, -1]
dy = [1, -1, 0, 0]

def bfs(board):
    n = len(board)
    price = [[int(1e9)] * n for _ in range(n)]
    price[0][0] = 0

    queue = deque()
    queue.append((0, 0, 0, 5))  # (시작X, 시작Y, 시작Cost, 시작방향)

    while queue:
        x, y, c, z = queue.popleft()

        if x == n - 1 and y == n - 1:
            continue

        for i in range(4):
            nx = x + dx[i]
            ny = y + dy[i]
            nz = i

            if nx < 0 or nx >= n or ny < 0 or ny >= n:
                continue
            if board[nx][ny] == 1:
                continue
            
            if z==5:
                nc = c + 100

            elif nz == z:
                nc = c + 100
                
            else:
                nc = c + 600

            if nc <= price[nx][ny]:
                price[nx][ny] = nc
                queue.append((nx, ny, nc, i))

    return price[-1][-1]


def solution(board):
    n = len(board)
    answer = bfs(board)
    return answer
```

Actually this is Dijskstra question

### 미로 탈출
https://school.programmers.co.kr/learn/courses/30/lessons/159993

My wrong code
```python
from collections import deque
def solution(maps):
    #     why is test cas3 -1??
#     cuz my bfs search marks visited as True for an answerpath that needs to be visited later, but cannot be visited cuz it is already visited
    row = len(maps)
    col = len(maps[0])
    graph = [['1' for _ in range(col)] for _ in range(row)]
    for i in range(len(maps)):
        for j in range(len(maps[0])):
            if maps[i][j]=='S':
                start_pos = (i,j)
            elif maps[i][j]=='L':
                lever_pos = (i,j)
            elif maps[i][j] == 'E':
                end_pos = (i,j)
            graph[i][j]=maps[i][j]
    visited = [[False for _ in range(col)] for _ in range(row)]
    visited[start_pos[0]][start_pos[1]] = True

    moves = [[1,0],[-1,0],[0,-1],[0,1]]

    queue = deque()
    queue.append(((start_pos[0],start_pos[1]),0,False))
    while queue:
        cur_pos, cur_cost, flag = queue.popleft()
        cur_x, cur_y = cur_pos[0], cur_pos[1]
        if cur_x == end_pos[0] and cur_y == end_pos[1] and flag ==True:
            return cur_cost
        # if cur_x == lever_pos[0] and cur_y == lever_pos[1]:
        #     flag = True
        for move in moves:
            next_x, next_y = cur_x +move[0], cur_y+move[1]
            if next_x<0 or next_x >=row or next_y <0 or next_y >=col:
                continue
            if graph[next_x][next_y] =='X':
                continue
            if next_x == lever_pos[0] and next_y == lever_pos[1]:
                flag = True
            if not visited[next_x][next_y]:
                queue.append(((next_x,next_y),cur_cost+1,flag))
                visited[next_x][next_y]=True

    return -1
```

Instead, you need to do 2 bfs search - 1 from start to lever and 1 from
lever to end point. Another important note is that I don't pass visited
list as parameter to my bfs function because visited list **needs to be 
renewed** for each bfs search. So visited list needs to be freshly instantiated
within the function, not passes as a parameter because we are gonna
reuse it over and over again.

```python
from collections import deque

moves = [[1,0],[-1,0],[0,-1],[0,1]]
def solution(maps):
    #     why is test cas3 -1??
    #     cuz my bfs search marks visited as True for an answerpath that needs to be visited later, but cannot be visited cuz it is already visited
    row = len(maps)
    col = len(maps[0])
    graph = [['1' for _ in range(col)] for _ in range(row)]
    for i in range(len(maps)):
        for j in range(len(maps[0])):
            if maps[i][j]=='S':
                start_pos = (i,j)
            elif maps[i][j]=='L':
                lever_pos = (i,j)
            elif maps[i][j] == 'E':
                end_pos = (i,j)
            graph[i][j]=maps[i][j]


    val1  = bfs(start_pos,lever_pos,graph,maps)
    val2 = bfs(lever_pos,end_pos,graph,maps)
    return val1+val2 if val1>0 and val2>0 else -1

def bfs(start_pos,end_pos,graph,maps):
    row = len(maps)
    col = len(maps[0])
    queue = deque()
    queue.append(((start_pos[0],start_pos[1]),0))
    visited = [[False for _ in range(col)] for _ in range(row)]
    visited[start_pos[0]][start_pos[1]] = True
    while queue:
        cur_pos, cur_cost = queue.popleft()
        cur_x, cur_y = cur_pos[0], cur_pos[1]
        if cur_x == end_pos[0] and cur_y == end_pos[1]:
            return cur_cost
        # if cur_x == lever_pos[0] and cur_y == lever_pos[1]:
        #     flag = True
        for move in moves:
            next_x, next_y = cur_x +move[0], cur_y+move[1]
            if next_x<0 or next_x >=row or next_y <0 or next_y >=col:
                continue
            if graph[next_x][next_y] =='X':
                continue
            if not visited[next_x][next_y]:
                queue.append(((next_x,next_y),cur_cost+1))
                visited[next_x][next_y]=True

    return -1
```
