
---
layout: post
title: BFS template and practice questions
category: Data structure & Algorithms
tags:
  - Data structure & Algorithms
---
## Intro
Use queue for BFS to find **the shortest something**


## Practice questions
### 거리두기 확인하기
https://school.programmers.co.kr/learn/courses/30/lessons/81302

This question needs BFS search multiple times on the same board itself.
I didn't know how to get the value of BFS search result and if abnormal, append
to answer list. To do this, we can use **flag**. We first set flag as True
or value 1 and when BFS search comes out abnormal, we can set flag as False
based on that BFS search result condition.

Also, it is smart to optimise the movement loop like instead of 
```python
movements = [[1,0],[-1,0],[0,-1],[0,1]]
```

We can use a dictionary like 
```python
dic = {0: [0, -1], 1:[-1, 0], 2:[0, 1], 3:[1, 0]}
```

Also be very careful with difference on number 0 and alphabet O. I put it like
if place at dx,dy ='0' but it should have been alphabet O.

My attempt, which is wrong
```python
for i in range(4):
    nx = x + dic[i][0]
    ny = y + dic[i][1]
    nd = d + 1
    # if dx<0 or dy <0 or dx>=5 or dy >=5:
    #     continue
    if 0 <= dx < 5 and 0 <= dy < 5 and not visited[dx][dy]:
        visited[dx][dy]= True
        if place[dx][dy]=='P':
            if dist<=2:
                return 0
        elif place[dx][dy] =='0':
            if dist==1:
                queue.append([dx,dy,dist])
```

Correct
```python
from collections import deque
ans=[]

def bfs(place,pos):
  queue = deque([pos])
  visited = [[False for _ in range(5)] for _ in range(5)]
  dic = {0: [0, -1], 1:[-1, 0], 2:[0, 1], 3:[1, 0]}

  while queue:
    x,y,d = queue.popleft()
    visited[x][y] = True
    for i in range(4):
      dx = x + dic[i][0]
      dy = y + dic[i][1]
      dist = d+1
      if dx<0 or dy <0 or dx>=5 or dy >=5:
        continue
      if not visited[dx][dy]:
        visited[dx][dy]= True
        if place[dx][dy]=='P' and dist<=2:
          return 0
        elif place[dx][dy] =='O' and dist<=1:
          queue.append([dx,dy,dist])
  return 1


def solution(places):
  # global ans
  for place in places:
    flag =1
    for row in range(len(places[0])):
      for col in range(len(places)):
        if place[row][col]=='P':
          val = bfs(place,[row,col,0])
          if val == False:
            flag =0
    ans.append(1 if flag==1 else 0)
  return ans
```

### 
In my queue, the parameters that I store will lead to wrong answer. I store
the previous direction as well

My solution
```python
from collections import deque
def solution(board):
    visited= [[False for _ in range(len(board[0]))] for _ in range(len(board))]
    length = len(board)
    queue = deque()
    # queue.append((0, 0, 0, dir))
    answer=[]

    queue.append((0, 0, 1, 0, 0))
    queue.append((0,0,0,1,0))
    visited[0][0] = True

    while queue:
        moves = [[1,0],[-1,0],[0,-1],[0,1]]
        x,y,prevX,prevY, cost = queue.popleft()
        for move in moves:
            dx,dy= x+move[0],y+move[1]
            if dx<0 or dx>=len(board[0]) or dy<0 or dy>=length or board[dx][dy]==1:
                continue
            if dx == len(board[0]) - 1 and dy == length - 1:
                answer.append(cost)

            cost += check_direction(move[0],move[1],prevX,prevY,cost)
            print(cost)

            if not visited[dx][dy]:
                visited[dx][dy]= True
                queue.append((dx,dy,move[0],move[1],cost))
                print((dx,dy,move[0],move[1],cost))

    return min(answer)

def check_direction(nextX,nextY,prevX,prevY,cost):
    if prevX == nextX and prevY==nextY:
        cost+=100
    else:
        cost+=500
    return cost

solution([[0,0,0],[0,0,0],[0,0,0]])
```

But this will that when bfs starts on starting point 0,0, we can move both
directions - right and down. So in this case, we use a little trick that marks
a custom direction just for this edge case. We mark the direction as integer 5.

I tried fixing code like this but still didnt work. I think its cuz this
visited is not allowing other paths stored in my queue to explore properly.
Also my cost is mega huge idk why
```python
from collections import deque
def solution(board):
    visited= [[False for _ in range(len(board[0]))] for _ in range(len(board))]
    length = len(board)
    queue = deque()
    answer=[]

    # current x, current y, direction, cost
    queue.append((0, 0, 5, 0))
    visited[0][0] = True

    while queue:
        moves = [[1,0],[-1,0],[0,-1],[0,1]]
        x,y,prevDirection, cost = queue.popleft()
        for i in range(len(moves)):
            dx,dy= x+moves[i][0],y+moves[i][1]
            if dx<0 or dx>=len(board[0]) or dy<0 or dy>=length or board[dx][dy]==1:
                continue
            if dx == len(board[0]) - 1 and dy == length - 1:
                answer.append(cost)

            cost += check_direction(i,prevDirection,cost)
            print(cost)

            if not visited[dx][dy]:
                visited[dx][dy]= True
                queue.append((dx,dy,i,cost))
                print((dx,dy,i,cost))

    return min(answer)

def check_direction(currentDirection, prevDirection,cost):
    if prevDirection ==5:
        cost+=100
    elif currentDirection==prevDirection:
        cost+=100
    else:
        cost+=500
    return cost

solution([[0,0,0],[0,0,0],[0,0,0]])
```

But official solution is here. We actually dont create a visited list because
other paths stored in queue will not be able to visit the already-visited points
by another path that has been processed earlier. So instead, we allow possibility
that other paths will go back and forth and back and forth because there
is no mark of visited points. But we create a price 2d list that record
the smallest price of any path that visits that point.

Ok my explanation above is wrong (June 11th fix) So even though there is no
visited list, we have this condition that stop unnecessary paths from being
added to our queue. The condition is if the point that we are visiting has
a cost that is recorded and is higher than our current cost to visit it,
we override that value. So if our current cost is higher, that means there
is a path that has lower cost that has been already added to our queue. So,
we don't visit that point and try other path.

Like this:
```python
if nc <= price[nx][ny]:
    price[nx][ny] = nc
    queue.append((nx, ny, nc, i))
```

```python
from collections import deque

dx = [0, 0, 1, -1]
dy = [1, -1, 0, 0]

def bfs(board):
    n = len(board)
    price = [[int(1e9)] * n for _ in range(n)]
    price[0][0] = 0

    queue = deque()
    queue.append((0, 0, 0, 5))  # (시작X, 시작Y, 시작Cost, 시작방향)

    while queue:
        x, y, c, z = queue.popleft()

        if x == n - 1 and y == n - 1:
            continue

        for i in range(4):
            nx = x + dx[i]
            ny = y + dy[i]
            nz = i

            if nx < 0 or nx >= n or ny < 0 or ny >= n:
                continue
            if board[nx][ny] == 1:
                continue
            
            if z==5:
                nc = c + 100

            elif nz == z:
                nc = c + 100
                
            else:
                nc = c + 600

            if nc <= price[nx][ny]:
                price[nx][ny] = nc
                queue.append((nx, ny, nc, i))

    return price[-1][-1]


def solution(board):
    n = len(board)
    answer = bfs(board)
    return answer
```

Actually this is Dijskstra question

