---
layout: post
title: BFS
category: Data structure & Algorithms
tags:
  - Data structure & Algorithms
---
## Intro
Use queue for BFS to find **the shortest something**

Wrong
```python
for i in range(4):
    nx = x + dic[i][0]
    ny = y + dic[i][1]
    nd = d + 1
    # if dx<0 or dy <0 or dx>=5 or dy >=5:
    #     continue
    if 0 <= dx < 5 and 0 <= dy < 5 and not visited[dx][dy]:
        visited[dx][dy]= True
        if place[dx][dy]=='P':
            if dist<=2:
                return 0
        elif place[dx][dy] =='0':
            if dist==1:
                queue.append([dx,dy,dist])
```

Correct
```python
from collections import deque
ans=[]

def bfs(place,pos):
  queue = deque([pos])
  visited = [[False for _ in range(5)] for _ in range(5)]
  dic = {0: [0, -1], 1:[-1, 0], 2:[0, 1], 3:[1, 0]}

  while queue:
    x,y,d = queue.popleft()
    visited[x][y] = True
    for i in range(4):
      dx = x + dic[i][0]
      dy = y + dic[i][1]
      dist = d+1
      if dx<0 or dy <0 or dx>=5 or dy >=5:
        continue
      if not visited[dx][dy]:
        visited[dx][dy]= True
        if place[dx][dy]=='P' and dist<=2:
          return 0
        elif place[dx][dy] =='O' and dist<=1:
          queue.append([dx,dy,dist])
  return 1


def solution(places):
  # global ans
  for place in places:
    flag =1
    for row in range(len(places[0])):
      for col in range(len(places)):
        if place[row][col]=='P':
          val = bfs(place,[row,col,0])
          if val == False:
            flag =0
    ans.append(1 if flag==1 else 0)
  return ans
```

Turns out fuck I was writing alphabet O as number 0
