---
layout: post
title: Greedy algorithms and practice questions
category: Data structure & Algorithms
tags:
  - Data structure & Algorithms
---

## Greedy
### stack



## Practice question
### 큰 수 만들기
https://school.programmers.co.kr/learn/courses/30/lessons/42883

My first approach was not greedy but to generate all possibilities of combinations
and sort and get the highest value. But time complexity was really bad here
```python
def solution(number, k):
  length = len(number)-k
  perms = [''.join(map(str,perm)) for perm in combinations(number,length)]
  print(perms)
  print(sorted(perms,reverse=True)[0])
  return sorted(perms,reverse=True)[0]
```

Then, I sought help from sensei GPT. We can use greedy algorithm with stack
to iteratively build the resulting number by selecting the maximum digit 
at each step.

I tried that but strangely, this didnt work for
"4177252841", 4.
```python
def solution(nums, k):
  count =0
  stack = deque()
  for num in nums:
    if not stack:
      stack.append(num)
      continue
    while stack:
      if stack[-1] <num and count<k:
        stack.pop()
        stack.append(num)
        count+=1
      else:
        stack.append(num)
      break
  # stack.reverse()  # Reverse the stack in-place
  result = ''.join(stack)
  print(result)
  return result
```

I think there is something wrong with the if condition inside my while loop.


Correct solution
```python
from itertools import permutations,combinations
from collections import deque,defaultdict
def solution(nums, k):
    count = 0
    stack = deque()
    for num in nums:
        if not stack:
            stack.append(num)
            continue
        
        while stack and stack[-1] < num and count < k:
            stack.pop()
            count += 1
        stack.append(num)
    # official solution to handle edge case
    # while count < k:
    #     stack.pop()
    #     count += 1
    
    # my way
    while len(stack)>len(nums)-k:
      stack.pop()
    
    result = ''.join(stack)
    # print(result)
    return result
```

Notice that we have to handle edge case of solution("4321", 1) where
our count is still not >=k. Then, our stack is too long so we need to pop
the last element accordingly and increment count until stack is of appropriate
length.

### 구명보트
https://school.programmers.co.kr/learn/courses/30/lessons/42885

Right away I thought of 2 pointer approach but was not sure how to increment
boat count. But we do it like

my correct code:
```python
def solution(people, limit):
  people.sort()
  count =0
  left = 0
  right = len(people)-1
  while(left<=right):
    if(people[left]+people[right]<=limit):
      count+=1
      left+=1
      right-=1
    else:
      right-=1
      count+=1
  print(count)
  return count
```

official solution excluded the else statement like this. This is better
```python
def solution(people, limit):
    people.sort()  # Sort the people in ascending order of weight
    left = 0  # Pointer for the lightest person
    right = len(people) - 1  # Pointer for the heaviest person
    boats = 0  # Count of lifeboats used
    
    while left <= right:
        if people[left] + people[right] <= limit:
            left += 1  # Move the left pointer to the next person
        right -= 1  # Move the right pointer to the next person
        boats += 1  # Increment the count of lifeboats used
    
    return boats
```
