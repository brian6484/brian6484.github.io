---
date: 2022-01-24 14:35:23
layout: post
title: MOOC.fi Java Programming I Part 5
subtitle: Fundamentals of Java
description: Fundamentals of Java
image: https://res.cloudinary.com/dm7h7e8xj/image/upload/v1559825145/theme16_o0seet.jpg
optimized_image: https://res.cloudinary.com/dm7h7e8xj/image/upload/c_scale,w_380/v1559825145/theme16_o0seet.jpg
category: Java
tags:
  - Java
  - MOOC.fi
author: Jeonghwan Lee
---

Part 5

1. Learning object-oriented programming
    * Object-oriented programming is primarily about isolating concepts into their own entities or, in other words, **creating abstractions**.

    * Separating a concept into its own class has advantages. Firstly, certain details (such as the rotation of a hand) can be hidden inside the class (i.e., abstracted). Instead of typing an if-statement and an assignment operation, it's simple and enough to just call a clearly-named method advance(). Secondly, a class created from a distinct concept can serve multiple purposes. The resulting clock hand may be used as a building block for other programs as well - the class could be named CounterLimitedFromTop, for example. Lastly, since the details of the implementation of the clock hand are not visible to its user, they can be changed if desired.

    * Clock with OOP: 

    ```java
    public class ClockHand {
        private int value;
        private int limit;

        public ClockHand(int limit) {
            this.limit = limit;
            this.value = 0;
        }

        public void advance() {
            this.value = this.value + 1;

            if (this.value >= this.limit) {
                this.value = 0;
            }
        }

        public int value() {
            return this.value;
        }

        public String toString() {
            if (this.value < 10) {
                return "0" + this.value;
            }

            return "" + this.value;
        }
    }

    public class Clock {
        private ClockHand hours;
        private ClockHand minutes;
        private ClockHand seconds;

        public Clock() {
            this.hours = new ClockHand(24);
            this.minutes = new ClockHand(60);
            this.seconds = new ClockHand(60);
        }

        public void advance() {
            this.seconds.advance();

            if (this.seconds.value() == 0) {
                this.minutes.advance();

                if (this.minutes.value() == 0) {
                    this.hours.advance();
                }
            }
        }

        public String toString() {
            return hours + ":" + minutes + ":" + seconds;
        }
    }
    
    Clock clock = new Clock();

    while (true) {
        System.out.println(clock);
        clock.advance();
    }
    ```

    * Review OneMinute exercise. Note 

    * Object refers to an independent entity that contains both data (instance variables) and behavior (methods). Objects can come in different forms, like some describe problem-domain concepts and some help coordinate the interaction between objects. Objects interact through method calls that both request info from objects and give instructions to them.

    * Generally, each object has clearly defined boundaries and behaviors and is only aware of the objects that it needs to perform its task. In other words, the object hides its internal operations, providing access to its functionality through clearly defined methods. Moreover, the object is independent of any other object that it doesn't require to accomplish its task.

    * The state of an object is the value of its internal variables at any given point in time.

    * A class is a blueprint that defines the types of objects that can be created from it. It contains instance variables describing the object's data, a constructor or constructors used to create it, and methods that define its behavior.

2. Removing repetitive code (overloading methods and constructors)
    * Class can have multiple constructors (i.e. alternative ways to create objects). Having 2 or more constructors in a class is known as **constructor overloading**. A class can have multiple constructors that differ in the number and/or type of their parameters. But It's **not possible** to have **two constructors with the exact same parameters**.

    ```java
    public Person(String name) {
            this.name = name;
            this.age = 0;
            this.weight = 0;
            this.height = 0;
        }

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
        this.weight = 0;
        this.height = 0;
    }
    public static void main(String[] args) {
        Person paul = new Person("Paul", 24);
        Person ada = new Person("Ada");
    }
    ```

    * Calling constructor within constructor: The first constructor - the one that receives a name as a parameter - is in fact a special case of the second constructor - the one that's given both name and age. What if the first constructor could call the second constructor?

    * A constructor can be called from another constructor using the **this** keyword, which refers to this object.  this() is used for calling the default constructor from parameterised constructor.
    
    ```java
    public Product(String name, String location, int weight) {
        this.name = name;
        this.location = location;
        this.weight = weight;
    }
    
    public Product(String name){
        this(name,"shelf",1);
    }
    public Product(String name, String location){
        this(name,location,1);
    }
    public Product(String name, int weight){
        this(name,"shelf",weight);
    }
    ```

    * The first constructor does not do anything by itself, but instead calls the second constructor and asks it to set the age to 0. **this(name, 0)** means that call is automatically replaced with "copy-paste" of the second constructor in such a way that the age parameter is set to 0. Also, if a constructor calls another constructor, the constructor call, this(), **must be the first command** in the constructor. But order of constructors don't matter like second constructor can be before first and vice versa.

    * Method overloading in same way as constructor overloading: Once again, the parameters of the different versions must be different.

    ```java
    public void growOlder() {
        this.growOlder(1);
        //same as below code, u can do either
        //this.age = this.age + 1;
    }

    public void growOlder(int years) {
        this.age = this.age + years;
    }
    ``` 

    * OverloadedCounter exercise:

    ```java
    public class Counter {
        private int startValue;
        
        public Counter(int startValue){
            this.startValue= startValue;
        }
        public Counter(){
            this(0);
        }
        public int value(){
            return this.startValue;
        }
        public void increase(){
            this.startValue +=1;
        }
        public void decrease(){
            this.startValue -=1;
        }
        public void increase(int increaseBy){
            if(increaseBy>=0){
                this.startValue += increaseBy;
            }

        }
        
        public void decrease(int decreaseBy){
            if(decreaseBy>=0){
                this.startValue -= decreaseBy;
            }
        }
    }
    ```

3. Primitive and reference variables
    * Primitive variable's information is stored as the value of that variable, whereas a reference variable holds a reference to information related to that variable. reference variables are practically always objects in Java.

    * Primitive variable example:

    ```java
    int value = 10;
    System.out.println(value);
    ```java

    * Reference variable example:
    ```java
    public class Name {
        private String name;

        public Name(String name) {
            this.name = name;
        }
    }

    Name luke = new Name("Luke");
    System.out.println(luke);
    //prints Name@4aa298b7
    ```

    * In above example, we create a primitive int variable, and the number 10 is stored as its value. We create a reference variable called luke. A reference to an object is returned by the constructor of the Name class when we call it, and this reference is stored as the value of the variable. 

    * Assigning a value to a specific spot of an Array works much like assigning a value in a normal variable, but in the Array you must specify the index, i.e. to which spot you want to assign the value. The index is specified in square brackets.

    * find the size of the array through the associated variable length. Note it is not method so .length() doesn't work

    * When you use array as a parameter of a method, the method receives a copy of the reference to the array.

4. Strings
    * Strings can't be compared with with the equals operator ==. Use .equals() method 

    * .split() method returns an array of the resulting sub-parts

    * .contains() method -> Strings have a contains-method, which tells if a string contains another string

    * .chartAt() gets character as specified index of string 

    * Splitting a string always produces an array of strings. So if the text is of fixed format, we can assume the data in a specific index to always be of the a specific type and can use Integer.valueOf() to convert string to number for further calculations like sum 

    * .length() method exists for strings (rmb .length is not a method for array) 

    * revisit last exercise PersonalDetails

    ```java
    import java.util.ArrayList;
    import java.util.Scanner;

    public class PersonalDetails {

        public static void main(String[] args) {
            Scanner scanner = new Scanner(System.in);
            String input = scanner.nextLine();
            String longestName ="";
            int sum=0;
            int count=0;
            while(true){
                if(input.equals("")){
                    break;
                }
                String[] parts = input.split(",");
                
                if(parts[0].length()>longestName.length()){
                    longestName=parts[0];
                }
                
                sum += Integer.valueOf(parts[1]);
                count++;
            }
            if (count > 0) {
                System.out.println("Longest name:" + longestName) ;
                System.out.println("Age average: " + (1.0 * sum / count));
            } else {
                System.out.println("No input.");
        }
        }
    }
    ```









