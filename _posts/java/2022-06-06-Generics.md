---
date: 2022-06-06 14:35:23
layout: post
title: What is generics?
subtitle: Java 
description: Java
category: Java
tags:
  - Java
  - Head First Java
---

## Intro
Generics is often used to write *type-safe collections*. This means that compiler
stops you from putting a Dog into a list of Ducks.

Without generics, the compiler could not care less what you put into a
collection, because all collection implementations hold type Object. You
could put anything like String, Integer, Duck, Pumpkin in any ArrayList without 
generics; it’s like the ArrayList is declared as ArrayList<Object>.

> Without generics, the compiler would happily let you put a Pumpkin into an ArrayList that
was supposed to hold only Cat objects.
> 
> With generics, you can create type-safe collections where more problems are caught at
compile-time instead of runtime.

## 3 things about generics
1) Creating *instances* of generic class (like ArrayList)

When you make ArrayList, you have to declare the type of objects to be allowed in the
list like new ArrayList<Song>()

```java
new ArrayList<Song>();
```

2) Declare and assign *variables* of generic types
   
How does polymorphism really work with generic types? If you have an
ArrayList<Animal> reference variable, can you assign an
ArrayList<Dog> to it? What about a List<Animal> reference? Can you
assign an ArrayList<Animal> to it?

```java
List<Song> songList = new ArrayList<Song>();
```

3) Declare and invoke *methods* that take generic types

It is similar to point 2. If you have a method that has as a parameter, say, an ArrayList of
Animal objects, what does that really mean? Can you also pass it an
ArrayList of Dog objects? We’ll look at some subtle and tricky
polymorphism issues that are very different from the way you write
methods that take plain old arrays.

```java
void foo(List<Song> list);
x.foo(songList);
```

### How to use generic class (like ArrayList)?
This is point 1 out of 3.
The 2 areas in a generic class that you need to look are
1) class declaration
2) method declaration

<img src="/assets/images/posts/java/Generics/1_generic.png" title="제목" alt="아무거나" width="400"/>

"E" is the type used to create instance of ArrayList. You can think it as like
E = Type.

>Think of “E” as a stand-in for “the type of element you want this collection to hold and return.” (E is
for Element.)

So here, ArrayList<Song> means E becomes Song in **any** method or variable declaration
that uses E.

<img src="/assets/images/posts/java/Generics/2_generic.png" title="제목" alt="아무거나" width="400"/>

E is replaced by the **real** type, which is known as **type parameter** that you use
when creating ArrayList instance. That is why add() method for ArrayList won’t let you add anything except objects of a
reference type that’s compatible with the type of “E.” So if you make an
ArrayList<String>, the add() method suddenly becomes add(String o). If
you make the ArrayList of type Dog, suddenly the add() method becomes
add(Dog o).

E or T, anything that is a legal Java identifier.

### How to use generic methods?
This is point 3 out of 3.

A generic method means that the method declaration uses a type parameter
in its signature. We can use type parameters in several ways:

1) Use type parameter defined in class declaration
```java
public class ArrayList<E> extends AbstractList<E> ... {
    public boolean add (E o)
  }
```
When you declare a type parameter for the class, you can simply use
that type any place that you’d use a real class or interface type. The type
declared in the method argument is essentially replaced with the type
you use when you instantiate the class.

2) Use type parameter *not* defined in class declaration
```java
//here we can say ArrayList<T> bcos we delcared T at the start of method declaration
public <T extends Animal> void takeThing(ArrayList<T list>)
```

If the class itself doesn’t use a type parameter, you can still specify one
for a method, by declaring it in a really unusual (but available) space—
*before the return type*. This method says that T can be “any type of
Animal.

Btw: 
```java
public <T extends Animal> void takeThing(ArrayList<T list>)
//is not the same as 
public void takeThing(ArrayList<Animal> list)
```

The first one, where <T extends Animal> is part of the method declaration,
means that any ArrayList declared of a type that is Animal, or one of
Animal’s subtypes (like Dog or Cat), is legal. So you could invoke the top
method using an ArrayList<Dog>, ArrayList<Cat>, or ArrayList<Animal>.

But the one on the bottom, where the method argument is
(ArrayList<Animal> list) means that *only* an ArrayList<Animal> is legal. The first version takes an ArrayList of any type that is a
type of Animal (Animal, Dog, Cat, etc.), the second version takes only an
ArrayList of type Animal. Not ArrayList<Dog> or ArrayList<Cat>, but only
ArrayList<Animal>.

This violates polymorphism bcos we want arraylists containing subclasses of Animal
as method parameters too!

## Summary
>A generic class means that the class declaration includes a type parameter.
> 
>A generic method means that the method declaration uses a type parameter
in its signature
